<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>PDF Panel Selector</title>
  <style>
    #container { position: relative; display: inline-block; }
    canvas {
      border: 1px solid #aaa;
      display: block;
    }
    /* overlay sits exactly on top of pdfCanvas */
    #overlay {
      position: absolute;
      top: 0; left: 0;
      cursor: crosshair;
    }
    button.active { background: #ddd; }
  </style>
</head>
<body>
  <input type="file" id="fileInput" accept="application/pdf" />
  <button id="btnAdd">Add Panel</button>
  <button id="btnRemove">Remove Panel</button>
  <button id="btnCrop">Crop & Download All</button>
  <div id="container">
    <canvas id="pdfCanvas"></canvas>
    <canvas id="overlay"></canvas>
  </div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.min.js"></script>
  <script>
    // PDF.js setup
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.worker.min.js';

    // DOM refs
    const fileInput = document.getElementById('fileInput');
    const pdfCanvas = document.getElementById('pdfCanvas');
    const overlay   = document.getElementById('overlay');
    const pdfCtx    = pdfCanvas.getContext('2d');
    const octx      = overlay.getContext('2d');
    const btnAdd    = document.getElementById('btnAdd');
    const btnRemove = document.getElementById('btnRemove');
    const btnCrop   = document.getElementById('btnCrop');

    // State
    let pdfPage, scale = 1.5;
    let mode = 'none';          // 'none' | 'add' | 'remove'
    let startPt = null;         // {x,y} when drawing a new rect
    let activeRect = null;      // the rect being drawn
    let rects = [];             // all saved panels

    // Helpers
    function drawAll() {
      octx.clearRect(0,0,overlay.width,overlay.height);
      // draw existing panels
      octx.strokeStyle = 'red';
      octx.lineWidth = 2;
      rects.forEach(r => octx.strokeRect(r.x, r.y, r.w, r.h));
      // draw the one in progress
      if (activeRect) {
        octx.strokeStyle = 'blue';
        octx.strokeRect(activeRect.x, activeRect.y, activeRect.w, activeRect.h);
      }
    }

    function setMode(newMode) {
      mode = newMode;
      btnAdd.classList.toggle('active', mode === 'add');
      btnRemove.classList.toggle('active', mode === 'remove');
      overlay.style.pointerEvents = (mode === 'add' || mode === 'remove') ? 'auto' : 'none';
      // clear any in-progress draw when switching away
      if (mode !== 'add') {
        startPt = activeRect = null;
        drawAll();
      }
    }

    // 1) Load & render PDF
    fileInput.addEventListener('change', async e => {
      const data = await e.target.files[0].arrayBuffer();
      const pdf = await pdfjsLib.getDocument({data}).promise;
      pdfPage = await pdf.getPage(1);
      const v = pdfPage.getViewport({scale});
      [pdfCanvas, overlay].forEach(c => {
        c.width = v.width;
        c.height = v.height;
      });
      await pdfPage.render({ canvasContext: pdfCtx, viewport: v }).promise;
      // Reset any previous selections
      rects = [];
      setMode('none');
    });

    // 2) Switch modes
    btnAdd   .addEventListener('click', () => setMode(mode === 'add' ? 'none' : 'add'));
    btnRemove.addEventListener('click', () => setMode(mode === 'remove' ? 'none' : 'remove'));

    // 3) Drawing new rectangles
    overlay.addEventListener('mousedown', e => {
      if (mode !== 'add') return;
      startPt = { x:e.offsetX, y:e.offsetY };
    });
    overlay.addEventListener('mousemove', e => {
      if (mode !== 'add' || !startPt) return;
      const x1 = Math.min(startPt.x, e.offsetX);
      const y1 = Math.min(startPt.y, e.offsetY);
      const w  = Math.abs(startPt.x - e.offsetX);
      const h  = Math.abs(startPt.y - e.offsetY);
      activeRect = { x:x1, y:y1, w, h };
      drawAll();
    });
    overlay.addEventListener('mouseup', () => {
      if (mode !== 'add' || !activeRect) return;
      rects.push(activeRect);
      activeRect = startPt = null;
      drawAll();
    });

    // 4) Removing existing rectangles
    overlay.addEventListener('click', e => {
      if (mode !== 'remove') return;
      const px = e.offsetX, py = e.offsetY;
      // find topmost rect under click
      for (let i = rects.length - 1; i >= 0; i--) {
        const r = rects[i];
        if (px >= r.x && px <= r.x + r.w && py >= r.y && py <= r.y + r.h) {
          rects.splice(i, 1);
          drawAll();
          break;
        }
      }
    });

    // 5) Crop & download all panels
    btnCrop.addEventListener('click', () => {
  if (!rects.length) {
    return alert('No panels selected.');
  }

  rects.forEach((r, i) => {
    // 1) Render the panel into a temp canvas
    const tmp = document.createElement('canvas');
    tmp.width = r.w;
    tmp.height = r.h;
    tmp.getContext('2d')
       .drawImage(
         pdfCanvas,
         r.x, r.y, r.w, r.h,
         0, 0, r.w, r.h
       );

    // 2) Convert to Blob and send to your FastAPI refine endpoint
    tmp.toBlob(async (blob) => {
      const fd = new FormData();
      // 'file' matches your endpoint parameter name
      fd.append('file', blob, `panel-${i + 1}.png`);

      try {
        const resp = await fetch('/api/sketch/refine', {
          method: 'POST',
          body: fd
        });

        if (!resp.ok) {
          console.error(`Panel ${i + 1} failed:`, await resp.text());
          return;
        }

        const json = await resp.json();
        console.log(`Panel ${i + 1} enqueued:`, json);
        // Optionally, update your UI with job_id / status
        // e.g. show “Panel 1: Pending (job ${json.job_id})”
      } catch (err) {
        console.error('Network error:', err);
      }
    }, 'image/png');
  });
});

      // reset if you like
      // rects = []; drawAll();
      // setMode('none');
  </script>
</body>
</html>
