<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Merge Edited Panels</title>
  <link rel="stylesheet" href="style.css" />
</head>
<body>
  <h1>Merge Edited Panels Back Into PDF</h1>

  <div class="actions">
    <button id="btnMerge">Render with Edits</button>
    <button id="btnDownload" disabled>Download Merged PDF</button>
  </div>

  <div class="workspace">
    <div id="container">
      <canvas id="pdfCanvas"></canvas>
      <canvas id="overlay"></canvas>
    </div>

    <aside class="sidebar">
      <h2>Pasted panels</h2>
      <div id="editsList" class="edits-list">
        <p class="empty-note">Nothing pasted yet.</p>
      </div>
    </aside>
  </div>

  <!-- PDF.js as global -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.min.js"></script>

  <script type="module">
    import { get } from 'https://cdn.jsdelivr.net/npm/idb-keyval@6/+esm';
    import { PDFDocument } from 'https://cdn.skypack.dev/pdf-lib';

    const scale       = 1.5;
    const btnMerge    = document.getElementById('btnMerge');
    const btnDownload = document.getElementById('btnDownload');
    const pdfCanvas   = document.getElementById('pdfCanvas');
    const overlay     = document.getElementById('overlay');
    const pdfCtx      = pdfCanvas.getContext('2d');
    const olCtx       = overlay.getContext('2d');
    const editsList   = document.getElementById('editsList');

    // --- storage helpers ---
    const getPanels = () => JSON.parse(sessionStorage.getItem('panelsToRefine') || '[]');
    const setPanels = (panels) => sessionStorage.setItem('panelsToRefine', JSON.stringify(panels));

    (async () => {
      try {
        const file = await get('current-pdf');
        if (!file) {
          document.body.innerHTML = '<p>No PDF found in storage; please go back and re-select.</p>';
          return;
        }
        const arrayBuffer = await file.arrayBuffer();

        pdfjsLib.GlobalWorkerOptions.workerSrc =
          'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.6.172/pdf.worker.min.js';

        const pdf  = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
        const page = await pdf.getPage(1);
        const viewport = page.getViewport({ scale });

        [pdfCanvas, overlay].forEach(c => {
          c.width  = Math.floor(viewport.width);
          c.height = Math.floor(viewport.height);
        });

        await page.render({ canvasContext: pdfCtx, viewport }).promise;

        renderEditsList(); // build sidebar initially
      } catch (e) {
        console.error('PDF render failed:', e);
        alert('Failed to render PDF. Check console.');
      }
    })();

    // 1) Render the original PDF page from IndexedDB on load
    async function drawPanelsToOverlay() {
      const panels = getPanels();
      if (!panels.length) {
        olCtx.clearRect(0, 0, overlay.width, overlay.height);
        return false;
      }

      // Only enforce afterUrl on ACTIVE panels
      if (panels.some(p => p.active !== false && !p.afterUrl)) {
        alert('Some active panels do not have an edited image yet.');
        return false;
      }

      olCtx.clearRect(0, 0, overlay.width, overlay.height);

      const activePanels = panels.filter(p => p.active !== false);
      if (!activePanels.length) return false;

      await Promise.all(activePanels.map(async panel => {
        const img = new Image();
        // crossOrigin is optional; remove if your afterUrl is same-origin data/blob URL
        img.crossOrigin = 'anonymous';
        img.src = panel.afterUrl;
        await img.decode();
        const { x, y, w, h } = panel.coords;
        olCtx.drawImage(img, 0, 0, img.naturalWidth, img.naturalHeight, x, y, w, h);
      }));

      return true;
    }

    // 2) Click ‚Üí draw overlays, then enable download
    btnMerge.addEventListener('click', async () => {
      console.log('üîò Merge button clicked');
      const ok = await drawPanelsToOverlay();
      btnDownload.disabled = !ok;
    });

    // 3) Build & download a 1-page PDF from the composed canvas (base + overlay)
    btnDownload.addEventListener('click', async () => {
      try {
        const comp = document.createElement('canvas');
        comp.width  = pdfCanvas.width;
        comp.height = pdfCanvas.height;
        const cctx = comp.getContext('2d');
        cctx.drawImage(pdfCanvas, 0, 0);
        cctx.drawImage(overlay,   0, 0);

        const dataUrl  = comp.toDataURL('image/png');
        const pngBytes = await (await fetch(dataUrl)).arrayBuffer();

        const pdfDoc  = await PDFDocument.create();
        const page    = pdfDoc.addPage([comp.width, comp.height]);
        const pngImg  = await pdfDoc.embedPng(pngBytes);
        page.drawImage(pngImg, { x: 0, y: 0, width: comp.width, height: comp.height });

        const pdfBytes = await pdfDoc.save();
        const blob     = new Blob([pdfBytes], { type: 'application/pdf' });
        const url      = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = 'merged.pdf';
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
      } catch (err) {
        console.error('Failed to build merged PDF:', err);
        alert('Failed to build merged PDF. See console for details.');
      }
    });

    // --- NEW: sidebar rendering + deletion ---

    function renderEditsList() {
      const panels = getPanels();
      editsList.innerHTML = '';

      if (!panels.length) {
        editsList.innerHTML = '<p class="empty-note">Nothing pasted yet.</p>';
        btnDownload.disabled = true;
        olCtx.clearRect(0, 0, overlay.width, overlay.height);
        return;
      }

    panels.forEach((panel, idx) => {
      const item = document.createElement('div');
      item.className = 'edit-item';
      item.dataset.index = String(idx);

      const label = document.createElement('span');
      label.className = 'label';
      const displayNum = panel.id ?? (idx + 1);
      label.textContent = `Panel #${displayNum}`;

      const toggleBtn = document.createElement('button');
      toggleBtn.className = 'btn-toggle'; // ‚Üê IMPORTANT
      toggleBtn.type = 'button';
      const isInactive = panel.active === false;
      toggleBtn.textContent = isInactive ? 'Enable' : 'Disable';
      toggleBtn.setAttribute('aria-label', `${toggleBtn.textContent} panel ${displayNum}`);

      item.appendChild(label);
      item.appendChild(toggleBtn);
      editsList.appendChild(item);
      });
    }

    // Event delegation for delete clicks
    editsList.addEventListener('click', async (e) => {
        const btn = e.target.closest('.btn-toggle'); // ‚Üê match your new button class
        if (!btn) return;

        const item = btn.closest('.edit-item');
        const idx  = Number(item?.dataset.index ?? -1);
        if (idx < 0) return;

        const panels = getPanels();
        const panel = panels[idx];
        panel.active = panel.active === false ? true : false; // toggle active flag
        setPanels(panels);

        renderEditsList();
        const ok = await drawPanelsToOverlay(); // re-render overlay with new active/inactive state
        btnDownload.disabled = !ok;
    });

  </script>
</body>
</html>